# Exploring Generators from the ground up

Generators are a new feature in JavaScript 2015.

Here is the `identity` function (a function that returns its argument).

[source,js]
----
function identity(x) {
  return x
}

identity('Apple')
----
----
Apple
----


A Generator (capitalized means to say a generator function that is a factory
of generators) version of `identity` is different. It returns a constructed generator. This generator, as we will see, will also return the Generator's argument but only after a few procedures are executed.

[source,js]
----
function* GenIdentity(x) {
  return x
}

let generator = GenIdentity('Apple')
----

----
{ _:
   { _:
      { next:
         { value: [Function: next],
           writable: false,
           enumerable: false,
           configurable: false },
        throw:
         { value: [Function: throw],
           writable: false,
           enumerable: false,
           configurable: false },
        constructor:
         { value: [Function: GeneratorFunctionPrototype],
           writable: false,
           enumerable: false,
           configurable: true } } } }
----

This is our generator created by our Generator. We learn several things here.

- `generators` are instances of `GeneratorFunction`. We can therefore expect generator methods to be `this` sensitive (they are). We also now know that conceptually all `function* () {...}` are of type `GeneratorFunction` (in practice the best JavaScript lets us do is use `instanceof`).
- `generator` API consists of two methods: `next` and `throw`.
- It appears that the prototype chain goes two levels down, but I am not sure why.

Continuing; In order to return said Generator argument we must execute two more procedures. First we must invoke `generator.next()` to both at once "advance" the generator (mutative, more on this later) whilst returning a "generated container value" (hereafter referred to as `container`). Then, second, we must read the value from the property `container.value` which will finally contain said Generator argument.

1. **First Procedure**

[source,js]
----
// ...
let container = generator.next()
----
----
{ value:
   { value: 'Apple',
     writable: true,
     enumerable: true,
     configurable: true },
  done:
   { value: true,
     writable: true,
     enumerable: true,
     configurable: true } }
----

2. **Second Procedure**

[source,js]
----
// ...
container.value
----
----
Apple
----

So, to recap from the beginning:


[source,js]
----
//                                  (throw)             [done ]
// Generator    ->         generator(next ) -> container[value]
   GenIdentity  ('Apple')          .next   ()          .value
----
----
Apple
----

We now have a generated value which is a container. You can see `'Apple'` at `container.value`.  The container however has another Boolean property `done`. This reflects the state of the generator; `true` means the generator has no more values to produce, `false` means the opposite. This means `generator.next()` is not a pure function. Its execution does two things: return a conatiner value (as we saw) and mutate the state of the generator that `next` is being invoked upon.

If we think about it, the mere idea/pesence of `container.done` clearly implies that there is a stateful (AKA time-sensitive) relationship between a generator and its generated container values. The relationships are thus:

. At the birth of a container value its `.done` property correctly tells us the current state of the generator. At this time, `.done` is implicitly in a state of correctness. As a generator evolves (is mutated) however, `.done` implicity changes into a stale state (AKA out-of-date, inaccurate) because its value no longer correctly reflects the state of the generator.

. There is one edge-case where the implicit state mentioned above does not apply to a container value's `.done` property; when the container value is the last value that will be generated by the generator. More specifically it is impossible for a `.done` property of value `true` to become stale, and therefore we can say it is implicitly stateless.

These two points outline the primitive/core relationship between a generator and its generated values. A user is free to build there own abstractions that create new relationships of course.

This stateful and small logical footprint tells us that generators are very much a low-level procedural construct useable as a tool for building (AKA abstracting) richer Function Oriented or Object Oriented systems/tools. Because it is low-evel the quantity divergent ideas that can be built is high. For example consider something like Koa which uses the progressive nature of generators to model HTTP Server request-response semantics versus a completely different tool js-csp which implements Communicating Sequential Processes modeled after Go channels and Clojure Core.Async.
